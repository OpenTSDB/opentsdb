// This file is part of OpenTSDB.
// Copyright (C) 2018  The OpenTSDB Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package net.opentsdb.query.processor.merge;

import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.reflect.TypeToken;

import net.opentsdb.data.TimeSeries;
import net.opentsdb.data.TimeSeriesDataType;
import net.opentsdb.data.TimeSeriesId;
import net.opentsdb.data.TypedTimeSeriesIterator;
import net.opentsdb.query.QueryResult;
import net.opentsdb.query.processor.ProcessorFactory;

/**
 * A time series generated by the {@link Merger} processor. It must contain at
 * least one source before any of the iterator fetch functions are called. Once
 * {@link #id()}, {@link #types()}, {@link #iterator(TypeToken)} or 
 * {@link #iterators()} has been called, the implementation may not call
 * {@link #addSource(TimeSeries)}.
 * 
 * @since 3.0
 */
public class MergerTimeSeries implements TimeSeries {
  /** The node this series belongs to. */
  protected final Merger node;
  
  /** The query result this series belongs to. */
  protected final QueryResult result;
  
  /** The set of types in this series. */
  protected final Set<TypeToken<? extends TimeSeriesDataType>> types;
  
  /** The list of sources for this series. */
  protected Set<TimeSeries> sources;

  /** The constructed time series ID. */
  protected TimeSeriesId id;
  
  /**
   * Default ctor.
   * @param node The Non-null node this series belongs to.
   * @param result The result this source is a part of.
   */
  public MergerTimeSeries(final Merger node, final QueryResult result) {
    if (node == null) {
      throw new IllegalArgumentException("Node cannot be null");
    }
    this.node = node;
    this.result = result;
    types = Sets.newHashSetWithExpectedSize(1);
  }
  
  /**
   * Package private method to add a source to this group by. DO NOT add a 
   * source after fetching an iterator, reading the types or fetching the ID.
   * @param source A non-null time series source.
   * @throws IllegalArgumentException if an iterator has been fetched, the 
   * types have been read, the ID read or the source was null.
   */
  void addSource(final TimeSeries source) {
    if (source == null) {
      throw new IllegalArgumentException("Source cannot be null.");
    }
    if (id == null) {
      id = source.id();
    }
    if (sources == null) {
      sources = Sets.newHashSet();
    }
    sources.add(source);
    types.addAll(source.types());
  }
  
  @Override
  public TimeSeriesId id() {
    return id;
  }

  @Override
  public Optional<TypedTimeSeriesIterator> iterator(
      final TypeToken<? extends TimeSeriesDataType> type) {
    if (type == null) {
      throw new IllegalArgumentException("Type cannot be null.");
    }
    
    if (!types.contains(type)) {
      return Optional.empty();
    }
    final TypedTimeSeriesIterator iterator = 
        ((ProcessorFactory) node.factory()).newTypedIterator(type, node, result, sources);
    if (iterator == null) {
      return Optional.empty();  
    }
    return Optional.of(iterator);
  }

  @Override
  public Collection<TypedTimeSeriesIterator> iterators() {
    final Collection<TypeToken<? extends TimeSeriesDataType>> types = types(); // calc the union
    final List<TypedTimeSeriesIterator> iterators =
        Lists.newArrayListWithCapacity(types.size());
    for (final TypeToken<? extends TimeSeriesDataType> type : types) {
      iterators.add(((ProcessorFactory) node.factory()).newTypedIterator(type, node, result, sources));
    }
    return iterators;
  }

  @Override
  public Collection<TypeToken<? extends TimeSeriesDataType>> types() {
    return types;
  }

  @Override
  public void close() {
    for (final TimeSeries ts : sources) {
      ts.close();
    }
  }
  
  @VisibleForTesting
  Set<TimeSeries> sources() {
    return sources;
  }
}
