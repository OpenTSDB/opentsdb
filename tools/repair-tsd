#!/usr/bin/env python3

from subprocess import Popen, PIPE, TimeoutExpired, check_output
from random import shuffle
import time
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import logging
import pprint

log = logging.getLogger("repair-tsd")
log.setLevel(logging.INFO)
ch = logging.StreamHandler()
logformat = '%(asctime)s %(name)s %(levelname)s %(message)s'
formatter = logging.Formatter(logformat)
ch.setFormatter(formatter)
log.addHandler(ch)


class TSDRepair(object):
    def __init__(self, args):
        self.timeout = args.get("timeout", 360)
        self.time_range = args.get("time_range", 26280)
        self.tsd_path = args.get("tsd_path", "/usr/share/opentsdb/bin/tsdb")
        self.cfg_path = args.get("cfg_path", "/etc/opentsdb/opentsdb.conf")
        self.use_sudo = args.get("use_sudo", False)
        self.sudo_user = args.get("sudo_user", "opentsdb")
        self.log = logging.getLogger("repair-tsd.class")
        warn = "You have set a timeout of {} seconds.".format(self.timeout)
        warn += " All individual metric repairs are allowed to run"
        warn += " that long. Please don't cancel a repair while it"
        warn += " is running!"
        self.log.warning(warn)
        self.metrics = self._get_metrics()

    def _get_metrics(self):
        """
        Collect all metrics from OpenTSDB

        :returns: all metrics
        :rtype: list
        """
        proc = Popen('{} uid grep metrics ".*"'.format(self.tsd_path),
                     shell=True, stdout=PIPE, stderr=PIPE)
        results = proc.communicate()
        metrics = [m.split(" ")[1].strip(":")
                   for m in results[0].decode().split("\n") if m]
        metrics = [m for m in metrics if m and m != "\x00"]
        shuffle(metrics)
        self.log.info("There are {} metrics to process".format(len(metrics)))
        return metrics

    def process_metrics(self):
        """
        Run fsck on a list of metrics over a time range
        """
        failed_metrics = []
        base = "{} fsck".format(self.tsd_path)
        check_cmd = "{} uid metrics".format(self.tsd_path)
        if self.use_sudo:
            base = "sudo -u {} {}".format(self.sudo_user, base)
            check_cmd = "sudo -u {} {}".format(self.sudo_user, check_cmd)
        cmd = "{} {}h-ago sum".format(base, self.time_range)
        for index, metric in enumerate(self.metrics):
            try:
                check_output("{} {}".format(check_cmd, metric), shell=True)
            except Exception:
                log.warning("{} doesn't actually exist! Skipping...".format(metric))
                continue
            self.log.info("Repairing {} ({} of {}) ({} failed)".format(metric,
                                                                       index + 1,
                                                                       len(self.metrics),
                                                                       len(failed_metrics)))
            fullcmd = "{} {} --fix-all --compact".format(cmd, metric)
            metricproc = Popen(fullcmd, shell=True, stdout=PIPE, stderr=PIPE)
            try:
                results, err = metricproc.communicate(timeout=self.timeout)
            except TimeoutExpired:
                self.log.warning("{} failed to complete in window".format(metric))
                failed_metrics.append(metric)
            except Exception as e:
                self.log.error("General exception processing {} :: {}".format(metric,
                                                                              e))
            else:
                results = [r for r in results.decode().split("\n") if r][-26:]
                final_results = []
                for r in results:
                    line = r.split(" ")[6:]
                    try:
                        if int(line[-1]) != 0:
                            final_results.append(" ".join(line))
                    except Exception:
                        final_results.append(" ".join(line))
                runtime = final_results.pop(-1)
                result_str = "\n".join(final_results)
                self.log.debug("{} results:\n{}".format(metric, result_str))
                self.log.info("{}: {}".format(metric, runtime))
            # self.log.debug("Waiting 5 seconds to give HBase a break...")
            # time.sleep(5)
        self.log.info("{} metrics failed".format(len(failed_metrics)))
        self.metrics = failed_metrics


def cli_opts():
    parser = ArgumentParser(description="Repair all OpenTSDB metrics",
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--debug", action="store_true", default=False,
                        help="Show debug information")
    parser.add_argument("--time-range", default="730",
                        help="How many hours of time we collect to repair")
    parser.add_argument("--timeout", default="420",
                        help="How many seconds we allow each fsck to run")
    parser.add_argument("--retries", default="1",
                        help="How many times we should try failed metrics")
    parser.add_argument("--tsd-path", default="/usr/share/opentsdb/bin/tsdb",
                        help="Path to the OpenTSDB CLI binary")
    parser.add_argument("--cfg-path", default="/etc/opentsdb/opentsdb.conf",
                        help="Path to OpenTSDB config")
    parser.add_argument("--use-sudo", action="store_true",
                        default=False, help="Whether to switch user when running repairs")
    parser.add_argument("--sudo-user", default="opentsdb",
                        help="User to switch to...")
    return parser.parse_args()


def main():
    args = cli_opts()
    if args.debug:
        log.setLevel(logging.DEBUG)
    try:
        time_range = int(args.time_range)
    except Exception as e:
        log.error("Invalid time range {} :: {}".format(args.time_range, e))
    try:
        retries = int(args.retries)
    except Exception as e:
        log.error("Invalid retry number {} :: {}".format(args.retries, e))
    try:
        timeout = int(args.timeout)
    except Exception as e:
        log.error("Invalid timeout {} :: {}".format(args.timeout, e))

    repair_tool = TSDRepair({"timeout": timeout, "time_range": time_range,
                             "use_sudo": args.use_sudo, "sudo_user": args.sudo_user,
                             "tsd_path": args.tsd_path, "cfg_path": args.cfg_path})
    repair_tool.process_metrics()

    for x in range(0, retries):
        if not repair_tool.metrics:
            continue
        failed_str = "\n".join(repair_tool.metrics)
        log.debug("failed metrics:\n{}".format(pprint.pformat(failed_str)))
        log.info("Re-trying with failed metrics only...")
        repair_tool.process_metrics()
    log.info("After {} repair runs:".format(retries+1))
    log.info("{} un-repaired metrics".format(len(repair_tool.metrics)))


if __name__ == "__main__":
    main()
