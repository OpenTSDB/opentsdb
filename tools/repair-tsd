#!/usr/bin/env python3

from subprocess import Popen, PIPE, TimeoutExpired, check_output
from random import shuffle
import time
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import logging
import pprint

log = logging.getLogger("repair-tsd")
log.setLevel(logging.INFO)
ch = logging.StreamHandler()
logformat = '%(asctime)s %(name)s %(levelname)s %(message)s'
formatter = logging.Formatter(logformat)
ch.setFormatter(formatter)
log.addHandler(ch)


class TSDRepair(object):
    def __init__(self, args):
        """
        We'll magic number the timeout because we know each individual chunk should take
        less than one hour to complete. So 58 minutes * 60 seconds per minute is our
        time limit per metric chunk...
        """
        self.timeout = 58 * 60
        self.retries = args.get("retries", 1)
        self.time_range = args.get("time_range", 48)
        self.tsd_path = args.get("tsd_path", "/usr/share/opentsdb/bin/tsdb")
        self.cfg_path = args.get("cfg_path", "/etc/opentsdb/opentsdb.conf")
        self.use_sudo = args.get("use_sudo", False)
        self.sudo_user = args.get("sudo_user", "opentsdb")
        self.log = logging.getLogger("repair-tsd")
        self.base = "{} fsck --config={}".format(self.tsd_path, self.cfg_path)
        self.check_cmd = "{} uid --config={} metrics".format(self.tsd_path, self.cfg_path)
        if self.use_sudo:
            self.base = "sudo -u {} {}".format(self.sudo_user, self.base)
            self.check_cmd = "sudo -u {} {}".format(self.sudo_user, self.check_cmd)
        warn = "You have set a timeout of {} seconds.".format(self.timeout)
        warn += " All individual metric repairs are allowed to run"
        warn += " that long. Please don't cancel a repair while it"
        warn += " is running!"
        self.log.warning(warn)

    def _get_metrics(self):
        """
        Collect all metrics from OpenTSDB

        :returns: all metrics
        :rtype: list
        """
        proc = Popen('{} uid --config={} grep metrics ".*"'.format(self.tsd_path, self.cfg_path),
                     shell=True, stdout=PIPE, stderr=PIPE)
        results = proc.communicate()
        metrics = [m.split(" ")[1].strip(":")
                   for m in results[0].decode().split("\n") if m]
        metrics = [m for m in metrics if m and m != "\x00"]
        shuffle(metrics)
        self.log.info("There are {} metrics to process".format(len(metrics)))
        return metrics

    def _repair_metric(self, metric, timestr, chunk):
        self.log.debug("Running chunk {} for {}".format(chunk, metric))
        cmd = "{} {} sum".format(self.base, timestr)
        for x in range(0, self.retries + 1):
            self.log.debug("Repair try {} for {}".format(x + 1, timestr))
            fullcmd = "{} {} --fix-all --compact".format(cmd, metric)
            self.log.debug("Full command: {}".format(fullcmd))
            metricproc = Popen(fullcmd, shell=True, stdout=PIPE, stderr=PIPE)
            try:
                results, err = metricproc.communicate(timeout=self.timeout)
            except TimeoutExpired:
                self.log.debug("{} failed to complete in window (run {})".format(metric, x + 1))
                continue
            except Exception as e:
                self.log.error("General exception processing {} :: {}".format(metric,
                                                                              e))
            else:
                results = [r for r in results.decode().split("\n") if r][-26:]
                final_results = []
                # We'll only collect results that are non-0, since we're not super interested in stuff that didn't change
                for r in results:
                    # Strip the timestamp from the log line
                    line = r.split(" ")[6:]
                    try:
                        if int(line[-1]) != 0:
                            final_results.append(" ".join(line))
                    except Exception:
                        final_results.append(" ".join(line))
                # We'll always show the run time, so separate that from the other lines
                try:
                    runtime = int(final_results.pop(-1).split()[3].strip('[]'))
                except Exception:
                    self.log.error("Bad runtime results for {} :: {}".format(metric, final_results))
                result_str = "\n".join(final_results)
                self.log.debug("{} results:\n{}".format(metric, result_str))
                self.log.debug("{} (chunk {}): completed in {} seconds".format(metric, chunk, runtime))
                return []
        else:
            self.log.error("Failed to completely repair {}".format(metric))
            return metric

    def process_metrics(self):
        """
        Run fsck on a list of metrics over a time range
        """
        failed_metrics = []
        metrics = self._get_metrics()
        for index, metric in enumerate(metrics):
            try:
                check_output("{} {}".format(self.check_cmd, metric), shell=True)
            except Exception:
                log.warning("{} doesn't actually exist! Skipping...".format(metric))
                continue
            self.log.info("Repairing {} ({} of {}) ({} failed)".format(metric,
                                                                       index + 1,
                                                                       len(metrics),
                                                                       len(failed_metrics)))
            start_time = time.time()
            failed_metrics.append(self._repair_metric(metric, "1h-ago", 1))
            for x in range(2, self.time_range + 1):
                failed_metrics.append(self._repair_metric(metric, "{}h-ago {}h-ago".format(x, x - 1), x))
            runtime = time.time() - start_time
            self.log.info("{} took {} seconds to complete".format(metric, runtime))
        self.log.info("Failed metrics: {}".format(failed_metrics))
        return failed_metrics


def cli_opts():
    parser = ArgumentParser(description="Repair all OpenTSDB metrics",
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--debug", action="store_true", default=False,
                        help="Show debug information")
    parser.add_argument("--time-range", default="48",
                        help="How many hours of time we collect to repair")
    parser.add_argument("--retries", default="1",
                        help="How many times we should try failed metrics")
    parser.add_argument("--tsd-path", default="/usr/share/opentsdb/bin/tsdb",
                        help="Path to the OpenTSDB CLI binary")
    parser.add_argument("--cfg-path", default="/etc/opentsdb/opentsdb.conf",
                        help="Path to OpenTSDB config")
    parser.add_argument("--use-sudo", action="store_true",
                        default=False, help="Whether to switch user when running repairs")
    parser.add_argument("--sudo-user", default="opentsdb",
                        help="User to switch to...")
    return parser.parse_args()


def main():
    args = cli_opts()
    if args.debug:
        log.setLevel(logging.DEBUG)
    try:
        time_range = int(args.time_range)
    except Exception as e:
        log.error("Invalid time range {} :: {}".format(args.time_range, e))
    try:
        retries = int(args.retries)
    except Exception as e:
        log.error("Invalid retry number {} :: {}".format(args.retries, e))

    repair_tool = TSDRepair({"time_range": time_range, "use_sudo": args.use_sudo,
                             "sudo_user": args.sudo_user,
                             "tsd_path": args.tsd_path, "cfg_path": args.cfg_path,
                             "retries": retries})
    repair_tool.process_metrics()

    repair_tool.process_metrics()


if __name__ == "__main__":
    main()
